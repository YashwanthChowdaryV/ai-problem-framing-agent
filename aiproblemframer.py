# -*- coding: utf-8 -*-
"""AIProblemFramer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/136vKuP2qrPWliTyZJqFWv9vKz0gqLTSs
"""

!pip install -q fastapi uvicorn pyngrok firebase-admin \
  transformers sentence-transformers torch accelerate sentencepiece

from google.colab import files
files.upload()

import firebase_admin
from firebase_admin import credentials, firestore

if not firebase_admin._apps:
    cred = credentials.Certificate("serviceAccountKey.json")
    firebase_admin.initialize_app(cred)

db = firestore.client()
print("Firebase connected successfully")

from transformers import pipeline
from sentence_transformers import SentenceTransformer, util

# Summarization model
summarizer = pipeline(
    "summarization",
    model="facebook/bart-large-cnn"
)

# Zero-shot classification model
classifier = pipeline(
    "zero-shot-classification",
    model="facebook/bart-large-mnli"
)

# Semantic similarity model
embedder = SentenceTransformer(
    "sentence-transformers/all-MiniLM-L6-v2"
)

print("AI models loaded")

DOMAINS = [
    "Healthcare",
    "Education",
    "Business",
    "Technology",
    "Agriculture",
    "Environment",
    "Public Policy"
]

OPERATIONAL_KEYWORDS = [
    "workflow", "scheduling", "queue",
    "delay", "process", "administrative",
    "bottleneck", "overload"
]

class ProblemFramingAgent:

    def summarize(self, text):
        result = summarizer(
            text,
            max_length=120,
            min_length=50,
            do_sample=False
        )
        return result[0]["summary_text"]

    def detect_domain(self, summary):
        res = classifier(summary, DOMAINS)
        return res["labels"][0], round(res["scores"][0], 2)

    def detect_problem_type(self, summary):
        for word in OPERATIONAL_KEYWORDS:
            if word in summary.lower():
                return "Operational (Process & Resource Utilization)"
        return "General / Strategic"

    def semantic_consistency(self, original, summary):
        emb = embedder.encode([original, summary])
        return round(util.cos_sim(emb[0], emb[1]).item(), 2)

    def frame_problem(self, text):
        summary = self.summarize(text)
        domain, confidence = self.detect_domain(summary)
        problem_type = self.detect_problem_type(summary)
        consistency = self.semantic_consistency(text, summary)

        return {
            "Domain": domain,
            "Problem Type": problem_type,
            "Core Problem": summary,
            "Confidence Score": confidence,
            "Semantic Consistency": consistency,
            "Well-Framed Problem Statement": (
                f"How might we address the {problem_type.lower()} challenges "
                f"in the {domain.lower()} domain to resolve this issue effectively?"
            )
        }

agent = ProblemFramingAgent()

test_input = """
In many mid-sized hospitals, outpatient departments experience long patient wait times
despite having enough doctors. Patients complain about long queues and delayed consultations.
"""

agent.frame_problem(test_input)

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from datetime import datetime, timezone

app = FastAPI()
agent = ProblemFramingAgent()

# Enable CORS (important for frontend later)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

class ProblemRequest(BaseModel):
    problem_text: str

@app.get("/")
def root():
    return {"message": "AI Problem Framing Agent is running"}

@app.post("/analyze")
def analyze_problem(req: ProblemRequest):
    result = agent.frame_problem(req.problem_text)

    # Save to Firestore
    db.collection("problem_frames").add({
        "input": req.problem_text,
        "output": result,
        "timestamp": datetime.now(timezone.utc)
    })

    return result

import uvicorn
import threading

def run_server():
    uvicorn.run(app, host="0.0.0.0", port=8000)

threading.Thread(target=run_server).start()
print("FastAPI server started")

from pyngrok import ngrok

ngrok.kill()  # clean old tunnels
public_url = ngrok.connect(8000)
print("Public API URL:", public_url)

ngrok config add-authtoken 37L1QJvVqkZ20cZNx2gFzHGe62b_2gVgZT7fujS9fv2h37SdN

from pyngrok import ngrok

ngrok.set_auth_token("37L1QJvVqkZ20cZNx2gFzHGe62b_2gVgZT7fujS9fv2h37SdN")
print("ngrok auth token set")

from pyngrok import ngrok

ngrok.kill()  # clean old tunnels
public_url = ngrok.connect(8000)
print("Public API URL:", public_url)

from pyngrok import ngrok

ngrok.disconnect("https://haleigh-nonextendible-unduteously.ngrok-free.dev")
ngrok.kill()

print("All ngrok tunnels stopped")

public_url = ngrok.connect(8000)
print("New Public API URL:", public_url)